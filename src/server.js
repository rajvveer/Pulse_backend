require('dotenv').config();

// Import configurations first
const config = require('./config');
const databaseConfig = require('./config/database');
const firebaseConfig = require('./config/firebase');
const smtpConfig = require('./config/smtp');
const cacheService = require('./services/cacheService');

const app = require('./app');
const { createServer } = require('http');
const { Server } = require('socket.io');

const PORT = config.get('server.port');
const NODE_ENV = config.get('server.nodeEnv');

// Print configuration summary
config.printSummary();

// Create HTTP server
const server = createServer(app);

// Initialize Socket.IO
const io = new Server(server, {
  cors: {
    origin: config.get('cors.origin'),
    methods: ["GET", "POST"],
    credentials: config.get('cors.credentials')
  }
});

// Initialization function
async function initialize() {
  try {
    console.log('üöÄ Initializing Pulse Backend Services...\n');

    // 1. Connect to MongoDB
    console.log('üìö Connecting to MongoDB...');
    await databaseConfig.connect();

    // 2. Initialize Redis Cache
    console.log('üî¥ Testing Redis connection...');
    const redisHealth = await cacheService.ping();
    if (redisHealth) {
      console.log('‚úÖ Redis connected successfully');
    } else {
      console.warn('‚ö†Ô∏è  Redis connection failed - using fallback cache');
    }

    // 3. Initialize Firebase (optional)
    console.log('üî• Initializing Firebase...');
    await firebaseConfig.initialize();

    // 4. Initialize SMTP (optional)
    console.log('üìß Initializing SMTP...');
    await smtpConfig.initialize();

    // 5. Create database indexes
    console.log('üìù Creating database indexes...');
    await databaseConfig.createIndexes();

    console.log('\n‚úÖ All services initialized successfully!\n');

  } catch (error) {
    console.error('‚ùå Service initialization failed:', error);
    
    if (config.isProduction()) {
      console.error('üö® Exiting due to initialization failure in production');
      process.exit(1);
    } else {
      console.warn('‚ö†Ô∏è  Continuing with limited functionality in development');
    }
  }
}

// Socket.IO connection handling
io.on('connection', (socket) => {
  console.log(`üë§ User connected: ${socket.id}`);
  
  socket.on('disconnect', () => {
    console.log(`üëã User disconnected: ${socket.id}`);
  });

  // Real-time features for social app
  socket.on('join-room', (room) => {
    socket.join(room);
    console.log(`üìç User ${socket.id} joined room: ${room}`);
  });

  socket.on('leave-room', (room) => {
    socket.leave(room);
    console.log(`üö™ User ${socket.id} left room: ${room}`);
  });

  // Location-based room joining
  socket.on('join-location', (location) => {
    const locationRoom = `location_${Math.round(location.lat * 1000)}_${Math.round(location.lng * 1000)}`;
    socket.join(locationRoom);
    console.log(`üìç User ${socket.id} joined location: ${locationRoom}`);
  });

  // User presence
  socket.on('user-online', (userId) => {
    socket.userId = userId;
    socket.join(`user_${userId}`);
    io.emit('user-status', { userId, status: 'online' });
  });

  socket.on('user-typing', (data) => {
    socket.to(data.room).emit('user-typing', {
      userId: socket.userId,
      isTyping: data.isTyping
    });
  });
});

// Make io accessible to routes
app.set('socketio', io);

// Enhanced health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: 'Pulse Backend API',
    version: '1.0.0',
    environment: NODE_ENV
  });
});

// Detailed health check endpoint with full system information
app.get('/health/detailed', async (req, res) => {
  try {
    const startTime = Date.now();
    
    // Test all services
    const [databaseHealth, redisHealth] = await Promise.allSettled([
      databaseConfig.isHealthy(),
      cacheService.ping()
    ]);

    const health = {
      status: 'OK',
      timestamp: new Date().toISOString(),
      responseTime: `${Date.now() - startTime}ms`,
      
      // Service health checks
      services: {
        database: databaseHealth.status === 'fulfilled' ? databaseHealth.value : false,
        redis: redisHealth.status === 'fulfilled' ? redisHealth.value : false,
        firebase: firebaseConfig.isAvailable(),
        smtp: smtpConfig.isAvailable()
      },
      
      // Application info
      application: {
        name: 'Pulse Backend API',
        version: '1.0.0',
        environment: NODE_ENV,
        nodeVersion: process.version,
        uptime: Math.floor(process.uptime()),
        startTime: new Date(Date.now() - process.uptime() * 1000).toISOString()
      },
      
      // System info
      system: {
        platform: process.platform,
        arch: process.arch,
        memory: {
          used: `${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB`,
          total: `${Math.round(process.memoryUsage().heapTotal / 1024 / 1024)}MB`,
          external: `${Math.round(process.memoryUsage().external / 1024 / 1024)}MB`
        },
        cpu: {
          usage: process.cpuUsage()
        }
      },
      
      // Database info (if connected)
      database: databaseConfig.getConnectionStats(),
      
      // Redis info (if connected)  
      redis: redisHealth.status === 'fulfilled' && redisHealth.value ? 
        await cacheService.getStats().catch(() => ({ error: 'Stats unavailable' })) : 
        { connected: false },

      // Socket.io info
      socketio: {
        connected: io.engine.clientsCount,
        rooms: io.sockets.adapter.rooms.size
      },

      // Configuration summary
      config: {
        cors: config.get('cors.origin'),
        rateLimit: {
          windowMs: config.get('rateLimit.windowMs'),
          maxRequests: config.get('rateLimit.maxRequests')
        },
        features: {
          emailOTP: !!config.get('otp.email'),
          smsOTP: !!config.get('otp.smsGatewayUrl'),
          firebase: !!config.get('firebase.projectId'),
          cloudinary: !!config.get('media.cloudinary.cloudName')
        }
      }
    };

    // Determine overall health status
    const criticalServices = [health.services.database, health.services.redis];
    const allCriticalHealthy = criticalServices.every(status => status === true);
    const overallStatus = allCriticalHealthy ? 'OK' : 'DEGRADED';
    
    health.status = overallStatus;
    
    res.status(allCriticalHealthy ? 200 : 503).json(health);

  } catch (error) {
    console.error('Health check error:', error);
    res.status(500).json({
      status: 'ERROR',
      timestamp: new Date().toISOString(),
      error: error.message,
      service: 'Pulse Backend API'
    });
  }
});

// API status endpoint
app.get('/status', (req, res) => {
  res.json({
    api: 'Pulse Backend',
    version: '1.0.0',
    status: 'active',
    endpoints: {
      health: '/health',
      detailedHealth: '/health/detailed',
      auth: '/api/v1/auth',
      documentation: '/api/docs'
    },
    features: [
      'Multi-method authentication (Email, Phone, Google)',
      'Real-time Socket.IO support',
      'Redis caching',
      'MongoDB with geospatial indexing',
      'JWT + Refresh token system',
      'Rate limiting and security',
      'Email OTP verification',
      'User session management'
    ],
    timestamp: new Date().toISOString()
  });
});

// Start server after initialization
async function startServer() {
  try {
    // Initialize all services
    await initialize();

    // Start HTTP server
    server.listen(PORT, () => {
      console.log(`üöÄ Pulse Backend Server running on port ${PORT}`);
      console.log(`üåç Environment: ${NODE_ENV}`);
      console.log(`üîó API URL: http://localhost:${PORT}`);
      console.log(`üìã Health Check: http://localhost:${PORT}/health`);
      console.log(`üìä Detailed Health: http://localhost:${PORT}/health/detailed`);
      console.log(`üîß API Status: http://localhost:${PORT}/status`);
      console.log(`üîë Auth API: http://localhost:${PORT}/api/v1/auth/test`);
      console.log(`\nüéØ Ready for connections!`);
      console.log(`üì± Socket.IO ready for real-time features`);
      console.log(`üóÑÔ∏è  Database: ${databaseConfig.isConnected ? '‚úÖ' : '‚ùå'}`);
      console.log(`üî¥ Redis: ${cacheService.isConnected ? '‚úÖ' : '‚ùå'}`);
    });

  } catch (error) {
    console.error('‚ùå Server startup failed:', error);
    process.exit(1);
  }
}

// Graceful shutdown handlers
process.on('SIGTERM', async () => {
  console.log('\nüõë SIGTERM received. Shutting down gracefully...');
  
  server.close(async () => {
    console.log('üîå HTTP server closed');
    
    // Close Socket.IO
    io.close(() => {
      console.log('üì° Socket.IO server closed');
    });
    
    // Close database connection
    await databaseConfig.disconnect();
    
    // Close Redis connection
    await cacheService.disconnect();
    
    // Close SMTP connection
    await smtpConfig.close();
    
    console.log('üëã Graceful shutdown completed');
    process.exit(0);
  });

  // Force shutdown after 30 seconds
  setTimeout(() => {
    console.error('‚è∞ Forced shutdown after 30 seconds');
    process.exit(1);
  }, 30000);
});

process.on('SIGINT', async () => {
  console.log('\nüõë SIGINT received. Shutting down gracefully...');
  
  server.close(async () => {
    console.log('üîå HTTP server closed');
    
    // Close Socket.IO
    io.close(() => {
      console.log('üì° Socket.IO server closed');
    });
    
    // Close database connection
    await databaseConfig.disconnect();
    
    // Close Redis connection
    await cacheService.disconnect();
    
    // Close SMTP connection  
    await smtpConfig.close();
    
    console.log('üëã Graceful shutdown completed');
    process.exit(0);
  });

  // Force shutdown after 30 seconds
  setTimeout(() => {
    console.error('‚è∞ Forced shutdown after 30 seconds');
    process.exit(1);
  }, 30000);
});

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('üí• Uncaught Exception:', error);
  
  if (config.isProduction()) {
    console.error('üö® Exiting due to uncaught exception in production');
    process.exit(1);
  }
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('üö´ Unhandled Rejection at:', promise, 'reason:', reason);
  
  if (config.isProduction()) {
    console.error('üö® Exiting due to unhandled rejection in production');
    process.exit(1);
  }
});

// Start the server
startServer().catch(console.error);
